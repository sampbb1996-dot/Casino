/**
 * FairSpin MVP
 * - Single loop: simulated rewarded ad -> spin -> points
 * - Local-only state (prototype)
 * - Replace simulateRewardedAd() with a real rewarded video SDK later.
 */

const CONFIG = {
  dailyCap: 12,          // rounds per day per device (prototype)
  cooldownSeconds: 25,   // minimum seconds between rounds
  adSeconds: 10,         // simulated rewarded ad duration
};

// ---------- Storage helpers ----------
const KEY = "fairspin_mvp_v1";

function todayKey() {
  const d = new Date();
  // local day (ok for prototype)
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${yyyy}-${mm}-${dd}`;
}

function loadState() {
  const raw = localStorage.getItem(KEY);
  if (!raw) return freshState();
  try {
    const s = JSON.parse(raw);
    if (!s || typeof s !== "object") return freshState();
    // reset daily counters if day changed
    const tk = todayKey();
    if (s.day !== tk) {
      s.day = tk;
      s.roundsUsed = 0;
      s.lastPlayTs = 0;
    }
    // basic sane defaults
    s.balancePts = Number.isFinite(s.balancePts) ? s.balancePts : 0;
    s.roundsUsed = Number.isFinite(s.roundsUsed) ? s.roundsUsed : 0;
    s.lastPlayTs = Number.isFinite(s.lastPlayTs) ? s.lastPlayTs : 0;
    return s;
  } catch {
    return freshState();
  }
}

function freshState() {
  return {
    day: todayKey(),
    balancePts: 0,
    roundsUsed: 0,
    lastPlayTs: 0,
    // simple device id (prototype). Real abuse control is a later phase.
    deviceId: getOrCreateDeviceId(),
  };
}

function saveState(s) {
  localStorage.setItem(KEY, JSON.stringify(s));
}

function getOrCreateDeviceId() {
  const k = "fairspin_device_id";
  let v = localStorage.getItem(k);
  if (!v) {
    v = cryptoRandomId();
    localStorage.setItem(k, v);
  }
  return v;
}

function cryptoRandomId() {
  const arr = new Uint8Array(16);
  crypto.getRandomValues(arr);
  return [...arr].map(b=>b.toString(16).padStart(2,"0")).join("");
}

// ---------- UI ----------
const els = {
  balance: document.getElementById("balance"),
  roundsLeft: document.getElementById("roundsLeft"),
  cooldown: document.getElementById("cooldown"),
  result: document.getElementById("result"),
  playBtn: document.getElementById("playBtn"),
  resetBtn: document.getElementById("resetBtn"),
  dailyCapTxt: document.getElementById("dailyCapTxt"),
  cooldownTxt: document.getElementById("cooldownTxt"),
  wheel: document.getElementById("wheel"),

  adModal: document.getElementById("adModal"),
  adBar: document.getElementById("adBar"),
  adSeconds: document.getElementById("adSeconds"),
  adCancel: document.getElementById("adCancel"),
};

els.dailyCapTxt.textContent = `${CONFIG.dailyCap}`;
els.cooldownTxt.textContent = `${CONFIG.cooldownSeconds}`;

let state = loadState();
let cooldownTimer = null;

// ---------- Wheel drawing ----------
const ctx = els.wheel.getContext("2d");
const W = els.wheel.width, H = els.wheel.height;
const center = { x: W/2, y: H/2 };
const radius = Math.min(W,H)/2 - 10;

// segments represent reward tiers in points (not money).
// weights are handled separately by reward sampling, NOT by wheel segment size.
const segments = [
  { label: "0", pts: 0 },
  { label: "1", pts: 1 },
  { label: "2", pts: 2 },
  { label: "3", pts: 3 },
  { label: "5", pts: 5 },
  { label: "8", pts: 8 },
];

let wheelAngle = 0;

function drawWheel(angleRad=0) {
  ctx.clearRect(0,0,W,H);
  const n = segments.length;
  const slice = (Math.PI * 2) / n;

  for (let i=0;i<n;i++){
    const start = angleRad + i*slice;
    const end = start + slice;

    // alternate colors (we don't specify exact colors beyond simple HSL)
    ctx.beginPath();
    ctx.moveTo(center.x, center.y);
    ctx.arc(center.x, center.y, radius, start, end);
    ctx.closePath();

    ctx.fillStyle = `hsl(${(i*360/n)}, 70%, ${i%2?32:24}%)`;
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // label
    ctx.save();
    ctx.translate(center.x, center.y);
    ctx.rotate(start + slice/2);
    ctx.textAlign = "right";
    ctx.fillStyle = "rgba(231,238,247,.92)";
    ctx.font = "700 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`${segments[i].label}`, radius - 14, 7);
    ctx.restore();
  }

  // center cap
  ctx.beginPath();
  ctx.arc(center.x, center.y, 36, 0, Math.PI*2);
  ctx.fillStyle = "rgba(0,0,0,.25)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.12)";
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.fillStyle = "rgba(231,238,247,.92)";
  ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.textAlign = "center";
  ctx.fillText("SPIN", center.x, center.y + 4);
}

drawWheel(wheelAngle);

// ---------- Reward sampling (bounded + âfair feelâ) ----------
/**
 * Tuned for:
 * - Mostly small rewards
 * - Some zeros
 * - Rare âniceâ hits
 *
 * IMPORTANT:
 * This is points only. If you later map points->cash, keep EV bounded and abuse controlled.
 */
function sampleRewardPts() {
  // weights sum to 100
  const buckets = [
    { pts: 0, w: 20 },  // 20% zero
    { pts: 1, w: 28 },  // 28%
    { pts: 2, w: 22 },  // 22%
    { pts: 3, w: 16 },  // 16%
    { pts: 5, w: 10 },  // 10%
    { pts: 8, w: 4  },  // 4%
  ];
  const r = Math.random() * 100;
  let acc = 0;
  for (const b of buckets) {
    acc += b.w;
    if (r <= acc) return b.pts;
  }
  return 1;
}

function canPlayNow() {
  const now = Date.now();
  const roundsLeft = Math.max(0, CONFIG.dailyCap - state.roundsUsed);
  const since = (now - state.lastPlayTs) / 1000;
  const cdLeft = Math.max(0, Math.ceil(CONFIG.cooldownSeconds - since));
  return { ok: roundsLeft > 0 && cdLeft === 0, roundsLeft, cdLeft };
}

function updateUI() {
  const { roundsLeft, cdLeft } = canPlayNow();
  els.balance.textContent = String(state.balancePts);
  els.roundsLeft.textContent = String(roundsLeft);
  els.cooldown.textContent = cdLeft ? `${cdLeft}s` : "Ready";
  els.playBtn.disabled = !canPlayNow().ok;
  if (!els.playBtn.disabled) els.playBtn.textContent = "Watch ad to spin";
  else if (roundsLeft <= 0) els.playBtn.textContent = "Daily cap reached (come back tomorrow)";
  else els.playBtn.textContent = `Cooldownâ¦`;
}

function startCooldownTicker() {
  if (cooldownTimer) clearInterval(cooldownTimer);
  cooldownTimer = setInterval(() => {
    updateUI();
  }, 250);
}

updateUI();
startCooldownTicker();

// ---------- Simulated rewarded ad ----------
async function simulateRewardedAd() {
  // Opens a modal and waits CONFIG.adSeconds seconds.
  return new Promise((resolve, reject) => {
    const modal = els.adModal;
    const bar = els.adBar;
    const secondsEl = els.adSeconds;

    let remaining = CONFIG.adSeconds;
    let cancelled = false;

    function cleanup() {
      els.adCancel.onclick = null;
      modal.hidden = true;
      bar.style.width = "0%";
    }

    function tick() {
      if (cancelled) return;
      secondsEl.textContent = String(remaining);
      const pct = ((CONFIG.adSeconds - remaining) / CONFIG.adSeconds) * 100;
      bar.style.width = `${Math.min(100, pct)}%`;

      if (remaining <= 0) {
        cleanup();
        resolve(true);
        return;
      }
      remaining -= 1;
      setTimeout(tick, 1000);
    }

    els.adCancel.onclick = () => {
      cancelled = true;
      cleanup();
      reject(new Error("Ad closed"));
    };

    modal.hidden = false;
    secondsEl.textContent = String(remaining);
    bar.style.width = "0%";
    setTimeout(tick, 250);
  });
}

// ---------- Spin animation ----------
function spinToSegment(segmentIndex, durationMs=1700) {
  return new Promise((resolve) => {
    const n = segments.length;
    const slice = (Math.PI * 2) / n;

    // We want the chosen segment to land under the pointer at top (angle = -pi/2).
    // Pointer is at top, so target angle makes segment center align there.
    const targetCenterAngle = -Math.PI / 2;

    // Segment center at angle: wheelAngle + (i*slice + slice/2)
    // Solve for wheelAngle so that equals targetCenterAngle (mod 2pi).
    const segCenter = (segmentIndex * slice) + (slice / 2);
    const baseTarget = targetCenterAngle - segCenter;

    // add extra spins
    const extraSpins = 6 + Math.floor(Math.random() * 3); // 6-8 spins
    const finalTarget = baseTarget + extraSpins * Math.PI * 2;

    const start = wheelAngle;
    const delta = normalizeDelta(finalTarget - start);

    const t0 = performance.now();

    function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

    function frame(now) {
      const t = Math.min(1, (now - t0) / durationMs);
      const eased = easeOutCubic(t);
      wheelAngle = start + delta * eased;
      drawWheel(wheelAngle);
      if (t < 1) requestAnimationFrame(frame);
      else resolve(true);
    }
    requestAnimationFrame(frame);
  });
}

function normalizeDelta(d) {
  // Keep delta as given (we want multiple spins), but ensure it isn't accidentally tiny.
  if (Math.abs(d) < Math.PI * 6) {
    const sign = d >= 0 ? 1 : -1;
    return d + sign * Math.PI * 12;
  }
  return d;
}

function segmentIndexForPts(pts) {
  const i = segments.findIndex(s => s.pts === pts);
  return i >= 0 ? i : 1;
}

// ---------- Main flow ----------
async function playRound() {
  // 1) Gate
  const gate = canPlayNow();
  if (!gate.ok) return;

  els.result.textContent = "Ad loadingâ¦";
  els.playBtn.disabled = true;

  try {
    // 2) Rewarded ad (simulated)
    await simulateRewardedAd();

    // 3) Sample reward
    const pts = sampleRewardPts();
    const segIndex = segmentIndexForPts(pts);

    // 4) Spin
    els.result.textContent = "Spinningâ¦";
    await spinToSegment(segIndex);

    // 5) Apply reward + update counters
    state.balancePts += pts;
    state.roundsUsed += 1;
    state.lastPlayTs = Date.now();
    saveState(state);

    // 6) UI message
    if (pts === 0) els.result.textContent = "No reward this round. Try again.";
    else els.result.textContent = `You won +${pts} pts!`;

  } catch (e) {
    els.result.textContent = "Ad closed. No spin awarded.";
  } finally {
    updateUI();
  }
}

els.playBtn.addEventListener("click", playRound);

els.resetBtn.addEventListener("click", () => {
  localStorage.removeItem(KEY);
  localStorage.removeItem("fairspin_device_id");
  state = loadState();
  wheelAngle = 0;
  drawWheel(wheelAngle);
  els.result.textContent = "Reset complete.";
  updateUI();
});
